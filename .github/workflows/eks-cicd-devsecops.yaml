name: EKS CI/CD with DevSecOps, ArgoCD & Monitoring

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]
  workflow_dispatch:

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
  ARGOCD_ADMIN_PASSWORD: ${{ secrets.ARGOCD_ADMIN_PASSWORD }}
  ARGOCD_DEV_PASSWORD: ${{ secrets.ARGOCD_DEV_PASSWORD }}
  ARGOCD_OPS_PASSWORD: ${{ secrets.ARGOCD_OPS_PASSWORD }}
  ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
  MANIFESTS_REPO: ${{ secrets.MANIFESTS_REPO }}
  MANIFESTS_REPO_PAT: ${{ secrets.MANIFEST_REPO_PAT }}
  KUSTOMIZE_PATH: ${{ secrets.KUSTOMIZE_PATH }}

jobs:
  # ---------------------------
  # Shared DevSecOps Scan
  # ---------------------------
  devsecops-scan:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Gitleaks
        run: |
          curl -sSL https://github.com/zricethezav/gitleaks/releases/download/v8.24.3/gitleaks_8.24.3_linux_x64.tar.gz | tar -xz -C /usr/local/bin
      - name: Secret Scan
        run: |
          gitleaks detect \
            --redact \
            -v \
            --exit-code=2 \
            --report-format=sarif \
            --report-path=results.sarif \
            --config .gitleaks.toml
      - name: Upload SARIF
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: results.sarif

      - name: IaC Scan
        uses: bridgecrewio/checkov-action@v12
        with:
          directory: ./k8s

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: python, javascript

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3

  # ---------------------------
  # Matrix Build: Backend & Frontend
  # ---------------------------
  build-test-image:
    needs: devsecops-scan
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [backend, frontend]
    outputs:
      backend-image: ${{ steps.set-image.outputs.backend_image }}
      frontend-image: ${{ steps.set-image.outputs.frontend_image }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # ---------------------------
      # Setup service paths & local image name
      # ---------------------------
      - name: Setup service paths & image names
        run: |
          if [ "${{ matrix.service }}" == "backend" ]; then
            SERVICE_PATH=backend/app-flask
            IMAGE_NAME="backend:${{ github.sha }}"
          else
            SERVICE_PATH=frontend/event-manager
            IMAGE_NAME="frontend:${{ github.sha }}"
          fi
          echo "SERVICE_PATH=$SERVICE_PATH" >> $GITHUB_ENV
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV

      # ---------------------------
      # Backend CI
      # ---------------------------
      - name: Backend CI
        if: matrix.service == 'backend'
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/app-flask/requirements.txt
          pip install autopep8 flake8 pytest safety

          # Code formatting & linting
          autopep8 --in-place --aggressive --aggressive --recursive backend/app-flask/app/
          autopep8 --in-place --aggressive --aggressive --recursive backend/app-flask/tests/
          flake8 backend/app-flask/ --count --max-complexity=10 --max-line-length=120 --statistics

          # Run tests with PYTHONPATH
          export PYTHONPATH=$PYTHONPATH:backend/app-flask
          pytest backend/app-flask/tests --maxfail=1 --disable-warnings -q

          # Security scan
          safety scan --full-report || true

      # ---------------------------
      # Frontend CI
      # ---------------------------
      - name: Frontend CI
        if: matrix.service == 'frontend'
        run: |
          cd frontend/event-manager
          npm install
          if npm run | grep -q ' test'; then
            npm test
          else
            echo "No test script found, skipping tests."
          fi
          npm install --save-dev prettier eslint
          npx prettier --write .
          npx eslint . --fix || true
          npm audit --audit-level=high --omit=dev || true

      # ---------------------------
      # Build Docker Image
      # ---------------------------
      - name: Build Docker image
        run: |
          echo "Building Docker image: $IMAGE_NAME"
          docker build -t "$IMAGE_NAME" "$SERVICE_PATH"

      # ---------------------------
      # Configure AWS and push to ECR
      # ---------------------------
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Ensure ECR repository exists
        run: |
          if [ "${{ matrix.service }}" == "backend" ]; then
            REPO_NAME=devsecops-capstone-backend
          else
            REPO_NAME=devsecops-capstone-frontend
          fi
          aws ecr describe-repositories --repository-names $REPO_NAME || \
          aws ecr create-repository --repository-name $REPO_NAME

      - name: Sanitize ECR_REGISTRY
        run: |
          CLEAN_REGISTRY=$(echo "${ECR_REGISTRY}" | tr -d '\n' | tr -d '[:space:]')
          echo "ECR_REGISTRY=$CLEAN_REGISTRY" >> $GITHUB_ENV

      - name: Log in to Amazon ECR
        run: |
          aws ecr get-login-password --region $AWS_REGION \
            | docker login --username AWS --password-stdin $ECR_REGISTRY

      - name: Tag Docker image for ECR
        run: |
          if [ "${{ matrix.service }}" == "backend" ]; then
            docker tag "$IMAGE_NAME" "$ECR_REGISTRY/backend:latest"
          else
            docker tag "$IMAGE_NAME" "$ECR_REGISTRY/frontend:latest"
          fi

      - name: Push image to ECR
        run: |
          if [ "${{ matrix.service }}" == "backend" ]; then
            docker push "$ECR_REGISTRY/backend:latest"
          else
            docker push "$ECR_REGISTRY/frontend:latest"
          fi

      - name: Set image outputs
        id: set-image
        run: |
          if [ "${{ matrix.service }}" == "backend" ]; then
            echo "backend_image=$ECR_REGISTRY/backend:latest" >> $GITHUB_OUTPUT
          else
            echo "frontend_image=$ECR_REGISTRY/frontend:latest" >> $GITHUB_OUTPUT
          fi

  # ---------------------------
  # Deploy via ArgoCD & Kustomize
  # ---------------------------
  deploy:
    needs: build-test-image
    runs-on: ubuntu-latest
    steps:

      # Checkout manifests repo
      - name: Checkout manifests repo
        uses: actions/checkout@v4
        with:
          repository: ${{ secrets.MANIFESTS_REPO }}
          token: ${{ secrets.MANIFEST_REPO_PAT }}

      # Update Kustomize images
      - name: Update Kustomize images
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          yq -i '(.images[] | select(.name == "backend")).newName = "${{ needs.build-test-image.outputs.backend-image }}"' ${{ env.KUSTOMIZE_PATH }}/kustomization.yaml
          yq -i '(.images[] | select(.name == "frontend")).newName = "${{ needs.build-test-image.outputs.frontend-image }}"' ${{ env.KUSTOMIZE_PATH }}/kustomization.yaml
          git config user.name github-actions
          git config user.email github-actions@github.com
          git commit -am "Update backend & frontend images" || echo "No changes"
          git push origin HEAD:main

      # Install dependencies
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y apache2-utils curl

      # Install ArgoCD CLI
      - name: Install ArgoCD CLI
        run: |
          sudo curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          sudo chmod +x /usr/local/bin/argocd
          argocd version

      # Debug trimmed ArgoCD server
      - name: Debug ArgoCD server
        run: |
          SERVER=$(echo "${{ secrets.ARGOCD_SERVER }}" | tr -d '\n' | tr -d '[:space:]')
          echo "Trimmed ArgoCD server: '$SERVER'"

      # ArgoCD login
      - name: ArgoCD login
        run: |
          SERVER=$(echo "${{ secrets.ARGOCD_SERVER }}" | tr -d '\n' | tr -d '[:space:]')
          echo "Logging into ArgoCD at $SERVER"
          argocd login https://$SERVER \
            --username admin \
            --password ${{ secrets.ARGOCD_ADMIN_PASSWORD }} \
            --insecure

      # Configure ArgoCD users (dev, ops)
      - name: Configure ArgoCD users (dev, ops)
        run: |
          kubectl -n argocd patch configmap argocd-cm \
            --type merge \
            -p '{
              "data": {
                "accounts.dev": "apiKey, login",
                "accounts.ops": "apiKey, login"
              }
            }'
          kubectl -n argocd patch secret argocd-secret \
            --type merge \
            -p "{\"stringData\": {
              \"accounts.dev.password\": \"$(htpasswd -bnBC 10 \"\" \"${{ secrets.ARGOCD_DEV_PASSWORD }}\" | tr -d ':\n')\",
              \"accounts.ops.password\": \"$(htpasswd -bnBC 10 \"\" \"${{ secrets.ARGOCD_OPS_PASSWORD }}\" | tr -d ':\n')\"
            }}"
          kubectl -n argocd rollout restart deploy argocd-server

      # Sync apps
      - name: Sync apps
        run: |
          set -e
          for app in backend-app frontend-app; do
            argocd app sync $app
            argocd app wait $app --health --timeout 300
          done

      # Deploy monitoring stack
      - name: Deploy monitoring stack
        run: |
          kubectl apply -f k8s/monitoring/
          kubectl rollout status deployment/prometheus-deployment -n monitoring --timeout=120s
          kubectl rollout status deployment/grafana-deployment -n monitoring --timeout=120s
          kubectl rollout status statefulset/loki -n monitoring --timeout=120s

# name: EKS CI/CD with DevSecOps, ArgoCD & Monitoring
# on:
#   push:
#     branches: ["main"]
#   pull_request:
#     branches: ["main"]
#   workflow_dispatch:

# env:
#   AWS_REGION: ${{ secrets.AWS_REGION }}
#   ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
#   ARGOCD_ADMIN_PASSWORD: ${{ secrets.ARGOCD_ADMIN_PASSWORD }}
#   ARGOCD_DEV_PASSWORD: ${{ secrets.ARGOCD_DEV_PASSWORD }}
#   ARGOCD_OPS_PASSWORD: ${{ secrets.ARGOCD_OPS_PASSWORD }}
#   MANIFESTS_REPO: ${{ secrets.MANIFEST_REPO }}
#   MANIFESTS_REPO_PAT: ${{ secrets.MANIFEST_REPO_PAT }}
#   KUSTOMIZE_PATH: ${{ secrets.KUSTOMIZE_PATH }}

# jobs:
#   # ---------------------------
#   # Shared DevSecOps Scan
#   # ---------------------------
#   devsecops-scan:
#     runs-on: ubuntu-latest
#     permissions:
#       contents: write
#       security-events: write
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v4
#         with:
#           fetch-depth: 0

#       - name: Install Gitleaks
#         run: |
#           curl -sSL https://github.com/zricethezav/gitleaks/releases/download/v8.24.3/gitleaks_8.24.3_linux_x64.tar.gz | tar -xz -C /usr/local/bin

#       - name: Secret Scan
#         run: |
#           gitleaks detect \
#             --redact 100 \
#             -v \
#             --exit-code=2 \
#             --report-format=sarif \
#             --report-path=results.sarif \
#             --config .gitleaks.toml

#       - name: Upload SARIF
#         uses: github/codeql-action/upload-sarif@v2
#         with:
#           sarif_file: results.sarif

#       - name: IaC Scan
#         uses: bridgecrewio/checkov-action@master
#         with:
#           directory: ./k8s

#       - name: Initialize CodeQL
#         uses: github/codeql-action/init@v3
#         with:
#           languages: python, javascript

#       - name: Perform CodeQL Analysis
#         uses: github/codeql-action/analyze@v3

#   # ---------------------------
#   # Matrix Build: Backend & Frontend
#   # ---------------------------
#   build-test-image:
#     needs: devsecops-scan
#     runs-on: ubuntu-latest
#     strategy:
#       matrix:
#         service: [backend, frontend]
#     outputs:
#       backend-image: ${{ steps.set-image.outputs.backend_image }}
#       frontend-image: ${{ steps.set-image.outputs.frontend_image }}
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v4

#       - name: Setup service paths & image names
#         run: |
#           if [ "${{ matrix.service }}" == "backend" ]; then
#             SERVICE_PATH=backend/app-flask
#             IMAGE_NAME="${{ env.ECR_REGISTRY }}/backend:${{ github.sha }}"
#           else
#             SERVICE_PATH=frontend
#             IMAGE_NAME="${{ env.ECR_REGISTRY }}/frontend:${{ github.sha }}"
#           fi

#           # Strip any newlines
#           IMAGE_NAME=$(echo "$IMAGE_NAME" | tr -d '\n')

#           echo "SERVICE_PATH=$SERVICE_PATH" >> $GITHUB_ENV
#           echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV

#   backend-ci:
#     runs-on: ubuntu-latest
#     strategy:
#       matrix:
#         service: [backend]

#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v3

#       # Cache pip packages to speed up CI
#       - name: Cache Python packages
#         uses: actions/cache@v3
#         with:
#           path: ~/.cache/pip
#           key: ${{ runner.os }}-pip-${{ hashFiles('backend/app-flask/requirements.txt') }}
#           restore-keys: |
#             ${{ runner.os }}-pip-

#       # Install Python dependencies including autopep8, flake8, pytest, safety
#       - name: Install dependencies
#         run: |
#           python -m pip install --upgrade pip
#           pip install -r backend/app-flask/requirements.txt
#           pip install autopep8 flake8 pytest safety

#       # Apply autopep8 autofix to backend code
#       - name: Auto-fix Python code
#         run: |
#           autopep8 --in-place --aggressive --aggressive backend/app-flask/app/
#           autopep8 --in-place --aggressive --aggressive backend/app-flask/tests/

#       # Run linter (flake8)
#       - name: Lint backend code
#         run: |
#           flake8 backend/app-flask/ --count --max-complexity=10 --max-line-length=120 --statistics

#       # Run tests (pytest)
#       - name: Run backend tests
#         run: |
#           pytest backend/app-flask/ -q --disable-warnings --maxfail=1

#       # Run security check (safety)
#       - name: Security audit
#         run: |
#           safety check --full-report

#       - name: Lint & Test (Frontend)
#         if: matrix.service == 'frontend'
#         run: |
#           cd frontend/event-manager
#           npm install
#           npm test
#           npm audit --audit-level=high || true

#       - name: Build Docker image
#         run: |
#           echo "Building Docker image: $IMAGE_NAME"
#           docker build -t "$IMAGE_NAME" "$SERVICE_PATH"

#       - name: Trivy scan
#         uses: aquasecurity/trivy-action@0.24.0
#         with:
#           image-ref: ${{ env.IMAGE_NAME }}
#           severity: 'HIGH,CRITICAL'
#           exit-code: '1'

#       - name: Login to ECR
#         run: |
#           aws ecr get-login-password --region ${{ env.AWS_REGION }} \
#             | docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}

#       - name: Push image to ECR
#         run: docker push "$IMAGE_NAME"

#       - name: Set image outputs
#         id: set-image
#         run: |
#           if [ "${{ matrix.service }}" == "backend" ]; then
#             echo "backend_image=$IMAGE_NAME" >> $GITHUB_OUTPUT
#           else
#             echo "frontend_image=$IMAGE_NAME" >> $GITHUB_OUTPUT

#   # ---------------------------
#   # Deploy via ArgoCD & Kustomize
#   # ---------------------------
#   deploy:
#     needs: build-test-image
#     runs-on: ubuntu-latest
#     steps:
#       - name: Checkout manifests repo
#         uses: actions/checkout@v4
#         with:
#           repository: ${{ env.MANIFESTS_REPO }}
#           token: ${{ env.MANIFESTS_REPO_PAT }}

#       - name: Update Kustomize images
#         run: |
#           sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
#           sudo chmod +x /usr/local/bin/yq
#           yq -i ".images[0].newName = \"${{ needs.build-test-image.outputs.backend-image }}\"" ${{ env.KUSTOMIZE_PATH }}/kustomization.yaml
#           yq -i ".images[1].newName = \"${{ needs.build-test-image.outputs.frontend-image }}\"" ${{ env.KUSTOMIZE_PATH }}/kustomization.yaml
#           git config user.name github-actions
#           git config user.email github-actions@github.com
#           git commit -am "Update backend & frontend images" || echo "No changes"
#           git push origin HEAD:main

#       - name: Install htpasswd
#         run: sudo apt-get update && sudo apt-get install -y apache2-utils

#       - name: ArgoCD login
#         run: |
#           argocd login ${{ secrets.ARGOCD_SERVER }} \
#             --username admin \
#             --password ${{ env.ARGOCD_ADMIN_PASSWORD }} \
#             --insecure

#       - name: Configure ArgoCD users (dev, ops)
#         run: |
#           kubectl -n argocd patch configmap argocd-cm \
#             --type merge \
#             -p '{
#               "data": {
#                 "accounts.dev": "apiKey, login",
#                 "accounts.ops": "apiKey, login"
#               }
#             }'
#           kubectl -n argocd patch secret argocd-secret \
#             --type merge \
#             -p "{\"stringData\": {
#               \"accounts.dev.password\": \"$(htpasswd -bnBC 10 \"\" \"${{ env.ARGOCD_DEV_PASSWORD }}\" | tr -d ':\n')\",
#               \"accounts.ops.password\": \"$(htpasswd -bnBC 10 \"\" \"${{ env.ARGOCD_OPS_PASSWORD }}\" | tr -d ':\n')\"
#             }}"
#           kubectl -n argocd rollout restart deploy argocd-server

#       - name: Sync apps
#         run: |
#           set -e
#           for app in backend-app frontend-app; do
#             if ! argocd app sync $app; then
#               echo "Sync failed for $app. Rolling back..."
#               argocd app rollback $app 0
#               exit 1
#             fi
#             argocd app wait $app --health --timeout 300
#           done

#       - name: Deploy monitoring stack
#         run: |
#           kubectl apply -f k8s/monitoring/
#           kubectl rollout status deployment/prometheus-deployment -n monitoring --timeout=120s || true
#           kubectl rollout status deployment/grafana-deployment -n monitoring --timeout=120s || true
#           kubectl rollout status statefulset/loki -n monitoring --timeout=120s || true