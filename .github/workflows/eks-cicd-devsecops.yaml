name: EKS CI/CD with DevSecOps, ArgoCD & Monitoring

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]
  workflow_dispatch:

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
  ARGOCD_ADMIN_PASSWORD: ${{ secrets.ARGOCD_ADMIN_PASSWORD }}
  ARGOCD_DEV_PASSWORD: ${{ secrets.ARGOCD_DEV_PASSWORD }}
  ARGOCD_OPS_PASSWORD: ${{ secrets.ARGOCD_OPS_PASSWORD }}
  ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
  MANIFESTS_REPO: ${{ secrets.MANIFESTS_REPO }}
  MANIFESTS_REPO_PAT: ${{ secrets.MANIFEST_REPO_PAT }}
  KUSTOMIZE_PATH: ${{ secrets.KUSTOMIZE_PATH }}

jobs:
  # ---------------------------
  # Shared DevSecOps Scan
  # ---------------------------
  devsecops-scan:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Gitleaks
        run: |
          curl -sSL https://github.com/zricethezav/gitleaks/releases/download/v8.24.3/gitleaks_8.24.3_linux_x64.tar.gz | tar -xz -C /usr/local/bin
      - name: Secret Scan
        run: |
          gitleaks detect \
            --redact \
            -v \
            --exit-code=2 \
            --report-format=sarif \
            --report-path=results.sarif \
            --config .gitleaks.toml
      - name: Upload SARIF
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: results.sarif

      - name: IaC Scan
        uses: bridgecrewio/checkov-action@v12
        with:
          directory: ./k8s

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: python, javascript

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3

  # ---------------------------
  # Matrix Build: Backend & Frontend
  # ---------------------------
  build-test-image:
    needs: devsecops-scan
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [backend, frontend]
    outputs:
      backend-image: ${{ steps.set-image.outputs.backend_image }}
      frontend-image: ${{ steps.set-image.outputs.frontend_image }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # ---------------------------
      # Setup service paths & local image name
      # ---------------------------
      - name: Setup service paths & image names
        run: |
          if [ "${{ matrix.service }}" == "backend" ]; then
            SERVICE_PATH=backend/app-flask
            IMAGE_NAME="backend:${{ github.sha }}"
          else
            SERVICE_PATH=frontend/event-manager
            IMAGE_NAME="frontend:${{ github.sha }}"
          fi
          echo "SERVICE_PATH=$SERVICE_PATH" >> $GITHUB_ENV
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV

      # ---------------------------
      # Backend CI
      # ---------------------------
      - name: Backend CI
        if: matrix.service == 'backend'
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/app-flask/requirements.txt
          pip install autopep8 flake8 pytest safety

          # Code formatting & linting
          autopep8 --in-place --aggressive --aggressive --recursive backend/app-flask/app/
          autopep8 --in-place --aggressive --aggressive --recursive backend/app-flask/tests/
          flake8 backend/app-flask/ --count --max-complexity=10 --max-line-length=120 --statistics

          # Run tests with PYTHONPATH
          export PYTHONPATH=$PYTHONPATH:backend/app-flask
          pytest backend/app-flask/tests --maxfail=1 --disable-warnings -q

          # Security scan
          safety scan --full-report || true

      # ---------------------------
      # Frontend CI
      # ---------------------------
      - name: Frontend CI
        if: matrix.service == 'frontend'
        run: |
          cd frontend/event-manager
          npm install
          if npm run | grep -q ' test'; then
            npm test
          else
            echo "No test script found, skipping tests."
          fi
          npm install --save-dev prettier eslint
          npx prettier --write .
          npx eslint . --fix || true
          npm audit --audit-level=high --omit=dev || true

      # ---------------------------
      # Build Docker Image
      # ---------------------------
      - name: Build Docker image
        run: |
          echo "Building Docker image: $IMAGE_NAME"
          docker build -t "$IMAGE_NAME" "$SERVICE_PATH"

      # ---------------------------
      # Configure AWS and push to ECR
      # ---------------------------
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Ensure ECR repository exists
        run: |
          if [ "${{ matrix.service }}" == "backend" ]; then
            REPO_NAME=devsecops-capstone-backend
          else
            REPO_NAME=devsecops-capstone-frontend
          fi
          aws ecr describe-repositories --repository-names $REPO_NAME || \
          aws ecr create-repository --repository-name $REPO_NAME

      - name: Sanitize ECR_REGISTRY
        run: |
          CLEAN_REGISTRY=$(echo "${ECR_REGISTRY}" | tr -d '\n' | tr -d '[:space:]')
          echo "ECR_REGISTRY=$CLEAN_REGISTRY" >> $GITHUB_ENV

      - name: Log in to Amazon ECR
        run: |
          aws ecr get-login-password --region $AWS_REGION \
            | docker login --username AWS --password-stdin $ECR_REGISTRY

      - name: Tag Docker image for ECR
        run: |
          if [ "${{ matrix.service }}" == "backend" ]; then
            docker tag "$IMAGE_NAME" "$ECR_REGISTRY/backend:latest"
          else
            docker tag "$IMAGE_NAME" "$ECR_REGISTRY/frontend:latest"
          fi

      - name: Push image to ECR
        run: |
          if [ "${{ matrix.service }}" == "backend" ]; then
            docker push "$ECR_REGISTRY/backend:latest"
          else
            docker push "$ECR_REGISTRY/frontend:latest"
          fi

      - name: Set image outputs
        id: set-image
        run: |
          if [ "${{ matrix.service }}" == "backend" ]; then
            echo "backend_image=$ECR_REGISTRY/backend:latest" >> $GITHUB_OUTPUT
          else
            echo "frontend_image=$ECR_REGISTRY/frontend:latest" >> $GITHUB_OUTPUT
          fi

  # ---------------------------
  # Deploy via ArgoCD & Kustomize
  # ---------------------------
  deploy:
    needs: build-test-image
    runs-on: ubuntu-latest
    steps:

      # Checkout manifests repo
      - name: Checkout manifests repo
        uses: actions/checkout@v4
        with:
          repository: ${{ secrets.MANIFESTS_REPO }}
          token: ${{ secrets.MANIFEST_REPO_PAT }}

      # Update Kustomize images
      - name: Update Kustomize images
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          yq -i '(.images[] | select(.name == "backend")).newName = "${{ needs.build-test-image.outputs.backend-image }}"' ${{ env.KUSTOMIZE_PATH }}/kustomization.yaml
          yq -i '(.images[] | select(.name == "frontend")).newName = "${{ needs.build-test-image.outputs.frontend-image }}"' ${{ env.KUSTOMIZE_PATH }}/kustomization.yaml
          git config user.name github-actions
          git config user.email github-actions@github.com
          git commit -am "Update backend & frontend images" || echo "No changes"
          git push origin HEAD:main

      # Install dependencies
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y apache2-utils curl openssl

      # Configure AWS credentials
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # Configure kubectl to talk to EKS
      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --region $AWS_REGION \
            --name devsecops-cluster

      # Install ArgoCD CLI
      - name: Install ArgoCD CLI
        run: |
          sudo curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          sudo chmod +x /usr/local/bin/argocd
          argocd version --client

      # Generate self-signed TLS cert with SAN
      - name: Generate self-signed TLS cert
        run: |
          cat > openssl-san.cnf <<EOF
          [req]
          default_bits       = 2048
          distinguished_name = req_distinguished_name
          x509_extensions    = v3_req
          prompt             = no

          [req_distinguished_name]
          CN = kwanusutaskapp.duckdns.org

          [v3_req]
          subjectAltName = @alt_names

          [alt_names]
          DNS.1 = kwanusutaskapp.duckdns.org
          EOF

          openssl req -x509 -nodes -days 365 \
            -newkey rsa:2048 \
            -keyout argocd-selfsigned.key \
            -out argocd-selfsigned.crt \
            -config openssl-san.cnf

      # Create Kubernetes TLS secret
      - name: Create TLS secret
        run: |
          kubectl create secret tls argocd-server-tls \
            --key argocd-selfsigned.key \
            --cert argocd-selfsigned.crt \
            -n argocd --dry-run=client -o yaml | kubectl apply -f -

      # Patch ArgoCD server deployment to use TLS cert
      - name: Patch ArgoCD server deployment
        run: |
          kubectl -n argocd patch deployment argocd-server \
            --patch '{
              "spec": {
                "template": {
                  "spec": {
                    "volumes": [
                      { "name": "tls-cert", "secret": { "secretName": "argocd-server-tls" } }
                    ],
                    "containers": [
                      {
                        "name": "argocd-server",
                        "volumeMounts": [
                          { "name": "tls-cert", "mountPath": "/app/config/tls", "readOnly": true }
                        ],
                        "args": [
                          "--tls-cert=/app/config/tls/tls.crt",
                          "--tls-key=/app/config/tls/tls.key"
                        ]
                      }
                    ]
                  }
                }
              }
            }'

      # Restart ArgoCD server
      - name: Restart ArgoCD server
        run: |
          kubectl -n argocd rollout restart deploy argocd-server

      # Update DuckDNS dynamically with retry
      - name: Update DuckDNS IP
        env:
          DUCKDNS_TOKEN: ${{ secrets.DUCKDNS_TOKEN }}
        run: |
          FRONTEND_NAMESPACE=default       # change if your frontend is in a different namespace
          FRONTEND_SERVICE=frontend-service # replace with your actual frontend service name

          for i in {1..5}; do
            ELB_DNS=$(kubectl -n $FRONTEND_NAMESPACE get svc $FRONTEND_SERVICE -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
            if [ -n "$ELB_DNS" ]; then break; fi
            echo "ELB hostname not ready, retrying in 15s..."
            sleep 15
          done

          echo "Frontend service ELB DNS: $ELB_DNS"

          for i in {1..5}; do
            FRONTEND_IP=$(nslookup $ELB_DNS | awk '/^Address: / { print $2 }' | tail -n1)
            if [ -n "$FRONTEND_IP" ]; then break; fi
            echo "IP not resolved yet, retrying in 10s..."
            sleep 10
          done

          echo "Resolved Frontend IP: $FRONTEND_IP"
          curl -s "https://www.duckdns.org/update?domains=kwanusutaskapp&token=$DUCKDNS_TOKEN&ip=$FRONTEND_IP"
          echo "DuckDNS updated to $FRONTEND_IP"

      # Trust self-signed cert in runner
      - name: Trust ArgoCD self-signed cert
        run: |
          sudo cp argocd-selfsigned.crt /usr/local/share/ca-certificates/argocd.crt
          sudo update-ca-certificates

      # # ArgoCD login securely
      # - name: ArgoCD login
      #   env:
      #     ARGOCD_PASSWORD: ${{ secrets.ARGOCD_ADMIN_PASSWORD }}
      #   run: |
      #     SERVER="kwanusutaskapp.duckdns.org:443"
      #     echo "Logging into ArgoCD at $SERVER"
      #     argocd login "$SERVER" \
      #       --username admin \
      #       --password "$ARGOCD_PASSWORD" \
      #       --insecure \
      #       --grpc-web

      # ArgoCD login securely using self-signed cert
      - name: ArgoCD login
        env:
          ARGOCD_PASSWORD: ${{ secrets.ARGOCD_ADMIN_PASSWORD }}
        run: |
          SERVER="kwanusutaskapp.duckdns.org:443"

          # Add ArgoCD self-signed cert to a temporary CA file for CLI
          mkdir -p ~/.argocd
          cp argocd-selfsigned.crt ~/.argocd/ca.crt

          echo "Logging into ArgoCD at $SERVER using self-signed certificate"
          argocd login "$SERVER" \
            --username admin \
            --password "$ARGOCD_PASSWORD" \
            --certificate-authority ~/.argocd/ca.crt \
            --grpc-web

      # Configure ArgoCD users (dev, ops)
      - name: Configure ArgoCD users (dev, ops)
        env:
          DEV_PASSWORD: ${{ secrets.ARGOCD_DEV_PASSWORD }}
          OPS_PASSWORD: ${{ secrets.ARGOCD_OPS_PASSWORD }}
        run: |
          kubectl -n argocd patch configmap argocd-cm \
            --type merge \
            -p '{
              "data": {
                "accounts.dev": "apiKey, login",
                "accounts.ops": "apiKey, login"
              }
            }'
          kubectl -n argocd patch secret argocd-secret \
            --type merge \
            -p "{\"stringData\": {
              \"accounts.dev.password\": \"$(htpasswd -bnBC 10 \"\" \"$DEV_PASSWORD\" | tr -d ':\n')\",
              \"accounts.ops.password\": \"$(htpasswd -bnBC 10 \"\" \"$OPS_PASSWORD\" | tr -d ':\n')\"
            }}"
          kubectl -n argocd rollout restart deploy argocd-server

      # Sync apps
      - name: Sync apps
        run: |
          set -e
          for app in backend-app frontend-app; do
            argocd app sync $app --insecure --grpc-web
            argocd app wait $app --health --timeout 300 --insecure --grpc-web
          done

      # Deploy monitoring stack
      - name: Deploy monitoring stack
        run: |
          kubectl apply -f k8s/monitoring/
          kubectl rollout status deployment/prometheus-deployment -n monitoring --timeout=120s
          kubectl rollout status deployment/grafana-deployment -n monitoring --timeout=120s
          kubectl rollout status statefulset/loki -n monitoring --timeout=120s
